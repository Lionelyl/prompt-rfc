<p><def_state id="1">closed</def_state>
<def_state id="2">listen</def_state>
<def_state id="3">request</def_state>
<def_state id="4">respond</def_state>
<def_state id="5">partopen</def_state>
<def_state id="6">open</def_state>
<def_state id="7">closereq</def_state>
<def_state id="8">closing</def_state>
<def_state id="9">timewait</def_state>
<def_state id="None">stable</def_state>
<def_state id="None">changing</def_state>
<def_state id="None">unstable</def_state>
<def_event id="1">dccp-request</def_event>
<def_event id="2">dccp-response</def_event>
<def_event id="3">dccp-data</def_event>
<def_event id="4">dccp-ack</def_event>
<def_event id="5">dccp-dataack</def_event>
<def_event id="6">dccp-closereq</def_event>
<def_event id="7">dccp-close</def_event>
<def_event id="8">dccp-reset</def_event>
<def_event id="9">dccp-sync</def_event>
<def_event id="10">dccp-syncack</def_event>
<def_event id="11">timeout</def_event>

<control relevant="true">
	<trigger><ref_state id="3">request</ref_state>  	</trigger>
	<transition>a client socket enters this state , 	</transition>
	<action type="receive">from closed , 	</action>
	<action type="send">after sending <arg> a <ref_event id="1" type="send">dccp-request</ref_event> packet to try </arg> to initiate a connection . 	</action> 
</control>

<control relevant="true">
	<trigger><ref_state id="4">respond</ref_state>  	</trigger>
	<transition>a server socket enters this state , 	</transition>from listen , 
	<action type="receive">after receiving <arg> a <ref_event id="1" type="receive">dccp-request</ref_event> from a </arg> client . 	</action> 
</control>

<control relevant="true">
	<trigger><ref_state id="5">partopen</ref_state>  	</trigger>
	<transition>a client socket enters this state , 	</transition>from <ref_event id="1" type="None">request</ref_event> , 
	<action type="receive">after receiving <arg> a <ref_event id="2" type="receive">dccp-response</ref_event> from the </arg> server . 	</action>. this state represents the third phase of the three-way handshake . the client may send application <ref_event id="3" type="receive">data</ref_event> in this state , but it must include an acknowledgement number on all of its packets .  
</control>

<control relevant="true">
	<trigger><ref_state id="6">open</ref_state>  	</trigger>
	<action type="receive">the central <ref_event id="3" type="receive">data</ref_event> transfer portion of a dccp connection . 	</action>
	<transition>client and server sockets enter this state from <arg_source><ref_state id="5">partopen</ref_state></arg_source> and <ref_state id="4">respond</ref_state> , 	</transition>
	<trigger>respectively . 	</trigger>sometimes we speak of server-open and client-open states , 
	<transition>corresponding to the server ` s <ref_state id="6">open</ref_state> state and the client ` s <ref_state id="6">open</ref_state> state . 	</transition> 
</control>

<control relevant="true">
	<trigger><ref_state id="7">closereq</ref_state>  	</trigger>
	<transition>a server socket enters this state , 	</transition>from server-open , 
	<action type="receive">to order the client to <ref_event id="7" type="receive">close</ref_event> the connection and to hold timewait state . 	</action> 
</control>

<control relevant="true">
	<trigger><ref_state id="9">timewait</ref_state>  		</trigger>

	<control relevant="true">
		<trigger>a server or client socket remains in this state for <ref_event id="11" type="compute">2msl</ref_event> ( 4 minutes ) after the connection has been torn down , 		</trigger>to prevent mistakes due to the delivery of old packets . 
		<trigger>only one of the endpoints has to enter <ref_state id="9">timewait</ref_state> state ( the other can enter <ref_state id="1">closed</ref_state> state immediately ) , 		</trigger>and a server can <ref_event id="1" type="None">request</ref_event> its client to hold timewait state using the <ref_event id="6" type="None">dccp-closereq</ref_event> packet type . 
	</control>
</control>

<control relevant="true">
	<trigger>to start a negotiation for feature f/a , 	</trigger>
	<action type="send">dccp a will send <arg> a change l option </arg> ; 	</action>
</control>

<control relevant="true">
	<trigger>to start a negotiation for f/b , 	</trigger>
	<action type="send">it will send <arg> a change r option </arg> . 	</action>
</control>

<control relevant="true">
	<trigger>change options are retransmitted until some <ref_event id="2" type="receive">response</ref_event> is received . 	</trigger>
</control>

<control relevant="true">
	<trigger>confirm l and confirm r options complete feature negotiation and are sent in <ref_event id="2" type="send">response</ref_event> to change r and change l options , 	</trigger>
	<trigger>respectively . 	</trigger>
</control>

<control relevant="true">
<trigger>if an endpoint receives an invalid change option -- with an unknown  </trigger>
<variable>feature number , 	</variable>or an invalid value -- it will respond with an empty confirm option containing the problematic feature number , but no value . 
</control>

<control relevant="true">
	<trigger>if there is no shared entry , 	</trigger>
	<action type="receive">the feature ` s value must not change , 	</action>
	<action type="receive">and the confirm option will confirm the feature ` s previous value ( unless the change option was mandatory ; see section 6.6.9 ) . 	</action> 
</control>

<control relevant="true">
<trigger>for example , 	</trigger>
	<action type="send">dccp a may send <arg> a <ref_event id="4" type="send">dccp-ack</ref_event> or <ref_event id="9" type="send">dccp-sync</ref_event> for feature negotiation only </arg> 	</action>
	<trigger>if the b-to-a ccid would allow sending a <ref_event id="4" type="send">dccp-ack</ref_event> . 	</trigger>in addition , 
	<action type="issue">an endpoint should generate <arg> at most one feature negotiation packet per round-trip time </arg> . 	</action>
</control>

<control relevant="true">
	<trigger>on receiving a change l or change r option , 	</trigger>
	<action type="receive">a dccp endpoint examines the included preference list , 	</action>
	<action type="receive">reconciles that with its own preference list , 	</action>
	<timer>calculates the new value , 	</timer>
	<action type="send">and sends back <arg> a confirm r or confirm l option </arg> , 	</action>
	<trigger>respectively , 	</trigger>
	<action type="receive">informing its peer of the new value or that the feature was not understood . 	</action>
</control>

<control relevant="true">
	<trigger>the confirm-sending endpoint changes its stored feature value as soon as it sends the confirm . 	</trigger>
</control>

<control relevant="true">
	<transition>an endpoint enters the <ref_state id="None">changing</ref_state> state 	</transition>
	<trigger>when it first sends a change for the feature 	</trigger>
</control>

<control relevant="true">
	<action type="receive">returns to stable once it receives <arg> a corresponding confirm </arg> . 	</action>
</control>

<control relevant="true">
	<trigger>the final state , 	</trigger>unstable , 
	<trigger>indicates that an endpoint in <ref_state id="None">changing</ref_state> state changed its preference list but has not yet transmitted a change option with the new preference list . 	</trigger> 
</control>

<control relevant="true">
	<trigger>first , 	</trigger>
	<action type="receive">check for unknown features ( section 6.6.7 ) ; 	</action> 
	<trigger>if f is unknown , 	</trigger> 

	<control relevant="true">
		<trigger>if the option was mandatory , 		</trigger>/* section 6.6.9 */  
		<action type="receive"><ref_event id="8" type="receive">reset</ref_event> connection and return  		</action>
		<trigger>otherwise , 		</trigger>
		<trigger>if o.type == change r , 		</trigger> 
		<action type="send">send <arg> empty confirm l </arg> on a future packet  	</action> return  
	</control>
</control>

<control relevant="true">
	<trigger>second , 	</trigger>
	<action type="receive">check for reordering ( section 6.6.4 ) ; 	</action> 
	<trigger>if f.state == <ref_state id="None">unstable</ref_state> or p.seqno &lt;= fgsr or ( o.type == confirm r and p.ackno &lt; fgss ) , 	</trigger> 
	<action type="receive">ignore option and return  	</action>
</control>

<control relevant="true">
	<trigger>third , 	</trigger>
	<transition>process change r options ; 	</transition> 
	<trigger>if o.type == change r , 	</trigger> 

	<control relevant="true">
		<trigger>if the option ` s value is valid , 		</trigger>/* section 6.6.8 */  calculate new value  
		<action type="send">send <arg> confirm l on a future packet </arg>  		</action>
		<transition>set f.state := stable  		</transition>
		<trigger>otherwise , 		</trigger>
		<trigger>if the option was mandatory , 		</trigger> 
		<action type="receive"><ref_event id="8" type="receive">reset</ref_event> connection and return  		</action>
		<trigger>otherwise , 		</trigger> 
		<action type="send">send <arg> empty confirm l </arg> on a future packet  		</action>/* 
		<transition>remain in existing state . 		</transition>
		<trigger>if that ` s <ref_state id="None">changing</ref_state> , 		</trigger>this  endpoint will retransmit its change l option later . */   
	</control>
</control>

<control relevant="true">
	<trigger>fourth , 	</trigger>
	<action type="receive">process confirm r options ( but only in changing state ) . 	</action> 
	<trigger>if f.state == <ref_state id="None">changing</ref_state> and o.type == confirm r , 	</trigger> 

	<control relevant="true">
		<trigger>if o.len &gt; 3 , 		</trigger>/* nonempty */  

		<control relevant="true">
			<trigger>if the option ` s value is valid , 			</trigger> 
			<trigger>set f.value := new value  			</trigger>
			<trigger>otherwise , 			</trigger> 
			<action type="receive"><ref_event id="8" type="receive">reset</ref_event> connection and return  		</action> 
		</control>
		<transition>set f.state := <ref_state id="None">stable</ref_state>  	</transition> 
	</control>
</control>

<control relevant="true">
	<trigger>a <ref_state id="None">changing</ref_state> endpoint transmits another change option once it realizes that it has not heard back from the other endpoint . 	</trigger>
</control>

<control relevant="true">
	<action type="send">the confirm-sending endpoint must generate a confirm option after every non-reordered change . 	</action>
</control>

<control relevant="true">
	<trigger>if a packet ` s sequence number is less than or equal to fgsr , 	</trigger>then  
	<action type="receive">its change options must be ignored . 	</action>
</control>

<control relevant="true">
	<trigger>if a packet ` s sequence number is less than or equal to fgsr , 	</trigger>
	<trigger>if it  	</trigger>has no acknowledgement number , or 
	<trigger>if its acknowledgement number is less than fgss , 	</trigger>
	<action type="receive">then its confirm options must be ignored . 	</action>
</control>

<control relevant="true">
	<trigger>an endpoint that changes its preference list 	</trigger>
	<transition>while in the <ref_state id="None">changing</ref_state> state must transition to the <ref_state id="None">unstable</ref_state> state . 	</transition>
</control>

<control relevant="true">
	<trigger>it will transition back to <ref_state id="None">changing</ref_state> once it has transmitted a change option with the new preference list . 	</trigger>
</control>

<control relevant="true">
	<trigger>the two endpoints might simultaneously <ref_state id="6">open</ref_state> negotiation for the same feature , 	</trigger>
	<trigger>after which an endpoint in the <ref_state id="None">changing</ref_state> state will receive a change option for the same feature . 	</trigger>such received change options can act as responses to the original change options . 
	<action type="receive">the changing endpoint must examine the received <arg> change </arg> ` s preference list , 	</action>
	<action type="issue">reconcile that with its own preference list ( as expressed in its generated <arg> change options </arg> ) , 	</action>
	<action type="issue">and generate <arg> the corresponding confirm option </arg> . 	</action>
	<action type="receive">it can 	</action>
	<transition>then transition to the <ref_state id="None">stable</ref_state> state . 	</transition>
</control>

<control relevant="true">
	<trigger>endpoints may receive change options referring to feature numbers they do not understand -- for instance , 	</trigger>
	<trigger>when an extended dccp converses with a non-extended dccp . 	</trigger>endpoints must respond to unknown change options with empty confirm options ( that is , confirm options containing no <ref_event id="3" type="None">data</ref_event> ) , which inform the changing endpoint that the feature was not understood . however , 

	<control relevant="true">
		<trigger>if the change option was mandatory , 	</trigger>
	</control>
	<action type="receive">the connection must be <ref_event id="8" type="receive">reset</ref_event> ; 	</action>see section 6.6.9 . 
</control>

<control relevant="true">
	<trigger>on receiving an empty confirm option for some feature , 	</trigger>
	<transition>the <ref_state id="None">changing</ref_state> endpoint must transition back to the <ref_state id="None">stable</ref_state> state , 	</transition>leaving the feature ` s value unchanged . 
</control>

<control relevant="true">
	<action type="receive">the changing endpoint should <ref_event id="8" type="receive">reset</ref_event> the connection ( with <ref_event id="8" type="receive">reset</ref_event> code 5 , `` option error `` ) 	</action>
	<trigger>if it receives an empty confirm option for such a feature . 	</trigger>
</control>

<control relevant="true">
	<trigger>since confirm options are generated only in <ref_event id="2" type="send">response</ref_event> to change options , 	</trigger>
	<action type="receive">an endpoint should never receive <arg> a confirm option referring to a feature number it does not understand </arg> . 	</action>nevertheless , endpoints must ignore any such options they receive . 
</control>

<control relevant="true">
	<action type="receive">an endpoint receiving <arg> an invalid change option </arg> must respond with the corresponding empty confirm option . 	</action>
</control>

<control relevant="true">
	<trigger>an endpoint receiving an invalid confirm option must <ref_event id="8" type="receive">reset</ref_event> the connection , 	</trigger>
	<trigger>with <ref_event id="8" type="receive">reset</ref_event> code 5 , 	</trigger>
	<error>`` option error `` . 	</error>
</control>

<control relevant="true">
	<trigger>change options may be preceded by mandatory options ( section 5.8.2 ) . 	</trigger>
	<trigger>mandatory change options are processed like normal change options except that the following failure cases will cause the receiver to <ref_event id="8" type="receive">reset</ref_event> the connection with <ref_event id="8" type="receive">reset</ref_event> code 6 , 	</trigger>
	<action type="receive">`` mandatory failure `` , 	</action>
	<action type="send">rather than send <arg> a confirm option </arg> . 	</action>
</control>

<control relevant="true">
	<action type="receive">the connection must be <ref_event id="8" type="receive">reset</ref_event> 	</action>
	<trigger>if :  	</trigger> o the change option ` s feature number was not understood ;  o the change option ` s value was invalid , and the receiver would normally have sent an empty confirm option in <ref_event id="2" type="None">response</ref_event> ; or   o for server-priority features , 
	<action type="receive">there was no shared entry in the two endpoints ` preference lists . 	</action>
</control>

<control relevant="true">
	<trigger>the simplest way to enforce this rule is for dccp endpoints to avoid sending any packets until one maximum segment lifetime ( 2 minutes ) after boot . 	</trigger>
</control>

<control relevant="true">
	<trigger>a received packet is classified as acknowledgeable 	</trigger>
	<trigger>if and only 	</trigger>
	<trigger>if its  	</trigger>
	<action type="receive">header was successfully processed by the receiving dccp . 	</action>
</control>

<control relevant="true">
	<trigger>a received packet becomes acknowledgeable 	</trigger>
	<trigger>when the receiving endpoint reaches step 8 . 	</trigger>
</control>

<control relevant="true">
	<trigger>endpoints <ref_state id="4">respond</ref_state> to received sequence-invalid packets as follows . 	</trigger>  
	<action type="receive">o any sequence-invalid <ref_event id="9" type="receive">dccp-sync</ref_event> or <ref_event id="10" type="receive">dccp-syncack</ref_event> packet must be ignored . 	</action>  
	<action type="receive">o a sequence-invalid <ref_event id="8" type="receive">dccp-reset</ref_event> packet must elicit a <ref_event id="9" type="receive">dccp-sync</ref_event> packet in <ref_event id="2" type="receive">response</ref_event> ( subject to a possible rate limit ) . 	</action>this <ref_event id="2" type="receive">response</ref_event> packet must use a new sequence number , and thus will increase gss ; 
	<transition>gsr will not change , 	</transition>however , since the received packet was sequence-invalid . 
	<variable>the <ref_event id="2" type="None">response</ref_event> packet ` s acknowledgement number must equal gsr . 	</variable>  
	<action type="receive">o any other sequence-invalid packet must elicit a similar <ref_event id="9" type="receive">dccp-sync</ref_event> packet , 	</action>except that the <ref_event id="2" type="receive">response</ref_event> packet ` s acknowledgement number must equal the sequence-invalid packet ` s sequence number . 
</control>

<control relevant="true">
	<trigger>on receiving a sequence-valid <ref_event id="9" type="receive">dccp-sync</ref_event> packet , 	</trigger>
	<action type="receive">the peer endpoint ( say , dccp b ) must update its gsr variable and reply with a dccp- <ref_event id="10" type="receive">syncack</ref_event> packet . 	</action>
	<trigger>the <ref_event id="10" type="receive">dccp-syncack</ref_event> packet ` s acknowledgement number will equal the <ref_event id="9" type="receive">dccp-sync</ref_event> ` s sequence number , 	</trigger>
	<action type="receive">which is not necessarily gsr . 	</action>
</control>

<control relevant="true">
	<trigger>upon receiving this <ref_event id="10" type="receive">dccp-syncack</ref_event> , 	</trigger>which will be sequence-valid since it acknowledges the <ref_event id="9" type="receive">dccp-sync</ref_event> , 
	<timer>dccp a will update its gsr variable , 	</timer>
	<transition>and the endpoints will be back in <ref_event id="9" type="None">sync</ref_event> . 	</transition>
</control>

<control relevant="true">
	<trigger>if the peer endpoint is in the <ref_state id="3">request</ref_state> state , 	</trigger>
	<action type="receive">it must respond with a <ref_event id="8" type="receive">dccp-reset</ref_event> instead of a <ref_event id="10" type="receive">dccp-syncack</ref_event> . 	</action>
</control>

<control relevant="true">
	<trigger>if , 	</trigger>
	<trigger>within that time , 	</trigger>
	<action type="receive">the relevant sequence windows change so that the packets become sequence-valid , 	</action>
	<action type="receive">the endpoint may process them again . 	</action>
</control>

<control relevant="true">
	<trigger>send <ref_event id="3" type="send">dccp-data</ref_event> packets with random sequence numbers . 	</trigger>
	<trigger>if one of these packets hits the valid sequence number window , 	</trigger>
	<action type="receive">the attack packet ` s application <ref_event id="3" type="receive">data</ref_event> may be inserted into the <ref_event id="3" type="receive">data</ref_event> stream . 	</action>
</control>

<control relevant="true">
	<trigger>send <ref_event id="9" type="send">dccp-sync</ref_event> packets with random sequence and acknowledgement numbers . 	</trigger>
	<trigger>if one of these packets hits the valid acknowledgement number window , 	</trigger>
	<action type="receive">the receiver will shift its sequence number window accordingly , 	</action>getting out of <ref_event id="9" type="receive">sync</ref_event> with the correct endpoint -- perhaps permanently .  
</control>

<control relevant="true">
	<trigger>if ref_low (&lt;) s /* 	</trigger>
	<variable>circular comparison mod 2^24 */ 	</variable> and s |&lt;| ref_low , /* conventional , non-circular  comparison */  
	<error>return ( ( ( ref_hi + 1 ) mod 2^24 ) &lt;&lt; 24 ) | s  	</error>
	<trigger>otherwise , 	</trigger>
	<trigger>if s (&lt;) ref_low and ref_low |&lt;| s , 	</trigger> 
	<error>return ( ( ( ref_hi - 1 ) mod 2^24 ) &lt;&lt; 24 ) | s  	</error>
	<trigger>otherwise , 	</trigger> 
	<variable>return ( ref_hi &lt;&lt; 24 ) | s  	</variable>
</control>

<control relevant="true">
	<trigger>when allow short seqnos/b is zero , 	</trigger>
	<action type="send">dccp b must not send <arg> packets with short sequence numbers </arg> and dccp a must ignore any packets with short sequence  	</action>  
	<action type="receive">rfc 4340 datagram congestion control protocol ( dccp ) march 2006  	</action>numbers that are received . 
</control>

<control relevant="true">
	<trigger>if a dccp endpoint ` s send ndp count feature is one ( see below ) , 	</trigger>
	<action type="send">then that endpoint must send <arg> an ndp count option on every packet whose </arg>  	</action>  
	<action type="receive">rfc 4340 datagram congestion control protocol ( dccp ) march 2006  	</action>immediate predecessor was a non-data packet . 
</control>

<control relevant="true">
	<variable>dccp b must send ndp count options as described above 	</variable>
	<trigger>when send ndp count/b is one , 	</trigger>
	<trigger>although it may send ndp count options even 	</trigger>
	<trigger>when send ndp count/b is zero . 	</trigger>
</control>

<control relevant="true">
	<trigger>when a client decides to initiate a connection , 	</trigger>
	<transition>it enters the <ref_state id="3">request</ref_state> state , 	</transition>
	<action type="receive">chooses an initial sequence number ( section 7.2 ) , 	</action>
	<action type="send">and sends <arg> a <ref_event id="1" type="send">dccp-request</ref_event> packet using that </arg> sequence number to the intended server . 	</action>
</control>

<control relevant="true">
	<timer>a client in the <ref_event id="1" type="send">request</ref_event> state should use an exponential-backoff timer to send new <ref_event id="1" type="send">dccp-request</ref_event> packets 	</timer>
	<trigger>if no <ref_event id="2" type="receive">response</ref_event> is received . 	</trigger>the first retransmission should occur after approximately one second , 
	<action type="receive">backing off to not less than one packet every 64 seconds ; 	</action>or the    
	<action type="receive">rfc 4340 datagram congestion control protocol ( dccp ) march 2006  	</action>endpoint can use whatever retransmission strategy is followed for retransmitting tcp syns . 
	<action type="receive">each new <ref_event id="1" type="receive">dccp-request</ref_event> must increment the sequence number by one and must contain the same service code and application <ref_event id="3" type="receive">data</ref_event> as the original <ref_event id="1" type="receive">dccp-request</ref_event> . 	</action>
</control>

<control relevant="true">
	<trigger>a client may give up on its dccp-requests after some time ( 3 minutes , for example ) . 	</trigger>
	<trigger>when it does , 	</trigger>
	<action type="send">it should send <arg> a <ref_event id="8" type="send">dccp-reset</ref_event> packet to the </arg> server with <ref_event id="8" type="send">reset</ref_event> code 2 , 	</action>
	<error>`` aborted `` , 	</error>to clean up state in case one or more of the requests actually arrived . 
</control>

<control relevant="true">
	<trigger>a client in <ref_state id="3">request</ref_state> state has never received an initial sequence number from its peer , 	</trigger>
	<variable>so the <ref_event id="8" type="None">dccp-reset</ref_event> ` s acknowledgement number must be set to zero . 	</variable>
</control>

<control relevant="true">
	<transition>the client leaves the <arg_source><ref_state id="3">request</ref_state></arg_source> state for <ref_state id="5">partopen</ref_state> 	</transition>
	<trigger>when it receives a <ref_event id="2" type="receive">dccp-response</ref_event> from the server . 	</trigger>
</control>

<control relevant="true">
	<trigger>if the <ref_event id="1" type="receive">dccp-request</ref_event> ` s service code does n ` t any of the server ` s service codes for the given port , 	</trigger>
	<action type="send">the server must reject the <ref_event id="1" type="send">request</ref_event> by sending <arg> a dccp- <ref_event id="8" type="send">reset</ref_event> packet with <ref_event id="8" type="send">reset</ref_event> code 8 </arg> , 	</action>
	<error>`` bad service code `` . 	</error>a middlebox may also send such a <ref_event id="8" type="None">dccp-reset</ref_event> in <ref_event id="2" type="None">response</ref_event> to packets whose service code is considered unsuitable .  
</control>

<control relevant="true">
	<trigger>the value 4294967295 is an invalid service code . 	</trigger>
	<trigger>servers must reject any <ref_event id="1" type="send">dccp-request</ref_event> with this service code value by sending a <ref_event id="8" type="send">dccp-reset</ref_event> packet with <ref_event id="8" type="send">reset</ref_event> code 8 , 	</trigger>
	<error>`` bad service code `` . 	</error>
</control>

<control relevant="true">
	<trigger>in the second phase of the three-way handshake , 	</trigger>
	<transition>the server moves from the <ref_state id="2">listen</ref_state> state to <ref_state id="4">respond</ref_state> and sends a <ref_event id="2" type="None">dccp-response</ref_event> message to the client 	</transition>
</control>

<control relevant="true">
	<trigger>the server may <ref_state id="4">respond</ref_state> to a <ref_event id="1" type="receive">dccp-request</ref_event> packet with a <ref_event id="8" type="receive">dccp-reset</ref_event> packet to refuse the connection . 	</trigger>relevant <ref_event id="8" type="None">reset</ref_event> codes for refusing a connection include 7 , 
	<error>`` connection refused `` , 	</error>
	<trigger>when the <ref_event id="1" type="receive">dccp-request</ref_event> ` s destination port did not correspond to a dccp port <ref_state id="6">open</ref_state> for listening ; 	</trigger>8 , 
	<error>`` bad service code `` , 	</error>
	<trigger>when the <ref_event id="1" type="receive">dccp-request</ref_event> ` s service code did not correspond to the service code registered with the destination port ; 	</trigger>and 9 , 
	<action type="receive">`` too busy `` , 	</action>
	<trigger>when the server is currently too busy to <ref_state id="4">respond</ref_state> to requests . 	</trigger>
	<variable>the server should limit the rate at which it generates these resets ; 	</variable>for example , 
	<trigger>to not more than 1024 per second . 	</trigger>
</control>

<control relevant="true">
	<trigger>every valid <ref_event id="1" type="receive">dccp-request</ref_event> received 	</trigger>
	<trigger>while the server is in the <ref_state id="4">respond</ref_state>  	</trigger>
	<action type="receive">state must elicit a new <ref_event id="2" type="receive">dccp-response</ref_event> . 	</action>
	<action type="receive">each new <ref_event id="2" type="receive">dccp-response</ref_event> must increment the server ` s sequence number by one and must include the same application <ref_event id="3" type="receive">data</ref_event> , 	</action>
	<trigger>if any , 	</trigger>
	<action type="receive">as the original <ref_event id="2" type="receive">dccp-response</ref_event> . 	</action>
</control>

<control relevant="true">
	<transition>the server leaves the <arg_source><ref_state id="4">respond</ref_state></arg_source> state for <arg_target><ref_state id="6">open</ref_state></arg_target> 	</transition>
	<trigger>when it receives a valid <ref_event id="4" type="receive">dccp-ack</ref_event> from the client , 	</trigger>
	<action type="send">completing the three-way handshake . 	</action>
</control>

<control relevant="true">
	<trigger>it may also leave the <ref_state id="4">respond</ref_state> state for <ref_state id="1">closed</ref_state> after a <ref_event id="11" type="receive">timeout</ref_event> of not less than <ref_event id="11" type="compute">4msl</ref_event> ( 8 minutes ) ; 	</trigger>
	<trigger>when doing so , 	</trigger>
	<action type="send">it should send <arg> a <ref_event id="8" type="send">dccp-reset</ref_event> with <ref_event id="8" type="send">reset</ref_event> code 2 , </arg> 	</action>
	<error>`` aborted `` , 	</error>
	<action type="receive">to clean up state at the client . 	</action>
</control>

<control relevant="true">
	<trigger>when the server receives the cookie back in the <ref_event id="2" type="receive">response</ref_event> , 	</trigger>
	<action type="receive">it can decrypt the cookie and instantiate all the state it avoided keeping . 	</action>
</control>

<control relevant="true">
	<trigger>in the meantime , 	</trigger>
	<transition>it need not move from the <arg_source><ref_state id="2">listen</ref_state></arg_source> state . 	</transition> 
</control>

<control relevant="true">
	<trigger>any init cookie options received on <ref_event id="1" type="receive">dccp-request</ref_event> or dccp- <ref_event id="3" type="receive">data</ref_event> packets , 	</trigger>
	<trigger>or after the connection has been established ( when the connection ` s state is &gt;= <ref_state id="6">open</ref_state> ) , 	</trigger>
	<action type="receive">must be ignored . 	</action>
</control>

<control relevant="true">
	<action type="receive">the server may include init cookie options in its <ref_event id="2" type="receive">dccp-response</ref_event> . 	</action>
	<trigger>if so , 	</trigger>
	<action type="receive">then the client must echo the same init cookie options , 	</action>
	<trigger>in the same order , 	</trigger>
	<action type="send">in each succeeding dccp packet until one of those packets is acknowledged ( showing that the three-way handshake has completed ) or the connection is <ref_event id="8" type="send">reset</ref_event> . 	</action>
</control>

<control relevant="true">
	<trigger>on receiving a reflected init cookie , 	</trigger>
	<action type="receive">the server would decrypt the cookie , 	</action>
	<action type="receive">validate it by checking its magic number , 	</action>sequence numbers , and ports , and , 

	<control relevant="true">
		<trigger>if valid , 		</trigger>
		<action type="receive">create a corresponding socket using the options . 		</action>
	</control>
</control>

<control relevant="true">
	<trigger>when the client receives a <ref_event id="2" type="receive">dccp-response</ref_event> from the server , 	</trigger>
	<transition>it moves from the <arg_source><ref_state id="3">request</ref_state></arg_source> state to <arg_target><ref_state id="5">partopen</ref_state></arg_target> and completes the three-way handshake by sending a <ref_event id="4" type="None">dccp-ack</ref_event> packet to the server . 	</transition>
</control>

<control relevant="true">
	<action type="receive">the client remains in partopen until it can be sure that the server has received <arg> some packet the client sent from partopen ( either the initial dccp- <ref_event id="4" type="receive">ack</ref_event> or a later packet ) </arg> . 	</action>
	<action type="send">clients in the partopen state that want to send <arg> <ref_event id="3" type="send">data</ref_event> </arg> must do so using <ref_event id="5" type="send">dccp-dataack</ref_event> packets , 	</action>not <ref_event id="3" type="send">dccp-data</ref_event> packets . 
</control>

<control relevant="true">
	<trigger>furthermore , 	</trigger>
	<trigger>if the <ref_event id="2" type="receive">dccp-response</ref_event> included an init cookie , 	</trigger>
	<action type="send">that init cookie must be included on <arg> every packet </arg> sent in partopen . 	</action>
</control>

<control relevant="true">
	<trigger>the single <ref_event id="4" type="send">dccp-ack</ref_event> sent 	</trigger>
	<trigger>when entering the <ref_state id="5">partopen</ref_state> state might , 	</trigger>of course , be dropped by the network . 
	<action type="receive">the client should ensure that some packet gets through eventually . 	</action>
	<timer>the preferred mechanism would be a roughly 200-millisecond timer , 	</timer>
	<trigger>set every time a packet is transmitted in <ref_state id="5">partopen</ref_state> . 		</trigger>

	<control relevant="true">
		<trigger>if this timer goes off and the client is still in <ref_state id="5">partopen</ref_state> , 		</trigger>
		<timer>the client generates another <ref_event id="4" type="send">dccp-ack</ref_event> and backs off the timer . 		</timer>
	</control>

	<control relevant="true">
		<trigger>if the client remains in <ref_state id="5">partopen</ref_state> for more than <ref_event id="11" type="compute">4msl</ref_event> ( 8 minutes ) , 		</trigger>
		<action type="receive">it should <ref_event id="8" type="receive">reset</ref_event> the connection with <ref_event id="8" type="receive">reset</ref_event> code 2 , 		</action>
		<transition>`` aborted `` 		</transition>
	</control>
</control>

<control relevant="true">
	<transition>the client leaves the <arg_source><ref_state id="5">partopen</ref_state></arg_source> state for <arg_target><ref_state id="6">open</ref_state></arg_target> 	</transition>
	<trigger>when it receives a valid packet other than <ref_event id="2" type="receive">dccp-response</ref_event> , 	</trigger>
	<trigger><ref_event id="8" type="receive">dccp-reset</ref_event> , 	</trigger>or <ref_event id="9" type="None">dccp-sync</ref_event> from the server . 
</control>

<control relevant="true">
	<action type="receive">dccp a sends <ref_event id="3" type="receive">dccp-data</ref_event> and <ref_event id="5" type="receive">dccp-dataack</ref_event> packets to dccp b due to application events on host a . 	</action>
</control>

<control relevant="true">
	<trigger><ref_event id="4" type="receive">dccp-ack</ref_event> packets are used 	</trigger>
	<trigger>when there is no <ref_event id="3" type="send">data</ref_event> to send from dccp a to dccp b , 	</trigger>
	<trigger>or 	</trigger>
	<trigger>when the congestion state of the a-to-b ccid will not allow <ref_event id="3" type="send">data</ref_event> to be sent . 	</trigger>
</control>

<control relevant="true">
	<trigger>on receiving a valid <ref_event id="9" type="receive">dccp-sync</ref_event> packet , 	</trigger>
	<action type="send">a dccp endpoint must immediately generate and send <arg> a <ref_event id="10" type="send">dccp-syncack</ref_event> <ref_event id="2" type="send">response</ref_event> ( subject to any implementation rate limits ) ; </arg> 	</action>
	<variable>the acknowledgement number on that <ref_event id="10" type="None">dccp-syncack</ref_event> must equal the sequence number of the <ref_event id="9" type="None">dccp-sync</ref_event> . 	</variable>
</control>

<control relevant="true">
	<trigger>dccp connection termination uses a handshake consisting of an optional <ref_event id="6" type="send">dccp-closereq</ref_event> packet , 	</trigger>
	<action type="receive">a <ref_event id="7" type="receive">dccp-close</ref_event> packet , 	</action>
	<action type="receive">and a <ref_event id="8" type="receive">dccp-reset</ref_event> packet . 	</action>
	<transition>the server moves from the <ref_state id="6">open</ref_state> state , possibly through the <ref_state id="7">closereq</ref_state> state , 	</transition>
	<action type="receive">to closed ; 	</action>
</control>

<control relevant="true">
	<transition>the client moves from <arg_source><ref_state id="6">open</ref_state></arg_source> through <arg_intermediate><ref_state id="8">closing</ref_state></arg_intermediate> to <arg_target><ref_state id="9">timewait</ref_state></arg_target> , and after <ref_event id="11" type="compute">2msl</ref_event> wait time ( 4 minutes ) to <ref_state id="1">closed</ref_state> . 	</transition>
</control>

<control relevant="true">
	<trigger>the sequence <ref_event id="6" type="receive">dccp-closereq</ref_event> , 	</trigger>
	<trigger><ref_event id="7" type="receive">dccp-close</ref_event> , 	</trigger>
	<trigger><ref_event id="8" type="receive">dccp-reset</ref_event> is used 	</trigger>
	<trigger>when the server decides to <ref_event id="7" type="receive">close</ref_event> the connection but does n ` t to hold <ref_state id="9">timewait</ref_state> state : 	</trigger>
</control>

<control relevant="true">
	<action type="receive">the receiver of a valid <ref_event id="6" type="receive">dccp-closereq</ref_event> packet must respond with a <ref_event id="7" type="receive">dccp-close</ref_event> packet . 	</action>
</control>

<control relevant="true">
	<trigger>the receiver of a valid <ref_event id="7" type="receive">dccp-close</ref_event> packet must <ref_state id="4">respond</ref_state> with a dccp- <ref_event id="8" type="receive">reset</ref_event> packet with <ref_event id="8" type="receive">reset</ref_event> code 1 , 	</trigger>
	<error>`` closed `` . 	</error>
</control>

<control relevant="true">
	<action type="receive">the receiver of a valid <ref_event id="8" type="receive">dccp-reset</ref_event> packet -- which is also the sender of the <ref_event id="7" type="receive">dccp-close</ref_event> packet ( and possibly the receiver of the <ref_event id="6" type="receive">dccp-closereq</ref_event> packet ) -- will hold timewait state for the connection . 	</action>
</control>

<control relevant="true">
	<transition>dccp implementations generally transition to the <arg_target><ref_state id="1">closed</ref_state></arg_target> state after sending a <ref_event id="8" type="None">dccp-reset</ref_event> packet . 	</transition>
</control>

<control relevant="true">
	<action type="receive">a server receiving <arg> a sequence-valid <ref_event id="6" type="receive">dccp-closereq</ref_event> packet must respond </arg> with a <ref_event id="9" type="receive">dccp-sync</ref_event> packet and 	</action>
	<action type="receive">otherwise ignore the dccp- <ref_event id="6" type="receive">closereq</ref_event> . 	</action>
</control>

<control relevant="true">
	<trigger><ref_event id="3" type="receive">dccp-data</ref_event> , 	</trigger>
	<trigger><ref_event id="5" type="receive">dccp-dataack</ref_event> , 	</trigger>
	<trigger>and <ref_event id="4" type="receive">dccp-ack</ref_event> packets received in <ref_state id="7">closereq</ref_state> or <ref_state id="8">closing</ref_state> states may be either processed or ignored . 	</trigger>
</control>

<control relevant="true">
	<trigger>if p.ackno exists , 	</trigger>
	<variable>then set r.seqno := p.ackno + 1 . 	</variable>
	<trigger>otherwise , 	</trigger> 
	<variable>set r.seqno := 0 . 	</variable> 
</control>

<control relevant="true">
	<trigger>if the packet used short sequence numbers ( p.x == 0 ) , 	</trigger>
	<variable>then set the  	</variable>
	<variable>upper 24 bits of r.seqno and r.ackno to 0 . 	</variable> 
</control>

<control relevant="true">
	<trigger>if the packet is shorter than 12 bytes , 	</trigger>
	<action type="receive">drop packet and return 	</action>
</control>

<control relevant="true">
	<trigger>if p.type is not understood , 	</trigger>
	<action type="receive">drop packet and return 	</action>
</control>

<control relevant="true">
	<trigger>if p.data offset is smaller than the given packet type ` s  	</trigger>
	<trigger>fixed header length or larger than the packet ` s length , 	</trigger>
	<action type="receive">drop packet and return 	</action>
</control>

<control relevant="true">
	<trigger>if p.type is not <ref_event id="3" type="receive">data</ref_event> , 	</trigger>
	<trigger><ref_event id="4" type="receive">ack</ref_event> , 	</trigger>
	<variable>or <ref_event id="5" type="None">dataack</ref_event> and p.x == 0 ( the packet  has short sequence numbers ) , 	</variable>
	<action type="receive">drop packet and return 	</action>
</control>

<control relevant="true">
	<trigger>if the header checksum is incorrect , 	</trigger>
	<action type="receive">drop packet and return 	</action>
</control>

<control relevant="true">
	<trigger>if p.cscov is too large for the packet size , 	</trigger>drop packet and  
	<action type="receive">return 	</action>
</control>

<control relevant="true">
	<action type="receive">look up flow id in table and get corresponding socket 	</action>
	<trigger>if no socket , 	</trigger>
	<trigger>or s.state == <ref_state id="9">timewait</ref_state> , 	</trigger> /* the following <ref_event id="8" type="None">reset</ref_event> ` s sequence and acknowledgement numbers  are taken from the input packet ; see section 8.3.1 . */  
	<trigger>generate <ref_event id="8" type="send">reset</ref_event> ( no connection ) unless p.type == <ref_event id="8" type="send">reset</ref_event> drop packet and return  	</trigger>
</control>

<control relevant="true">
	<trigger>if s.state == <ref_state id="2">listen</ref_state> , 	</trigger> 

	<control relevant="true">
		<trigger>if p.type == <ref_event id="1" type="receive">request</ref_event> or p contains a valid init cookie option , 		</trigger> /* must scan the packet ` s options to check for init  cookies . only init cookies are processed here , however ; other options are processed in step 8 . this scan need only be performed 
		<trigger>if the endpoint uses init cookies */ 		</trigger> /* 
		<variable>generate a new socket and switch to that socket */ 		</variable>
		<variable>set s := new socket for this port pair s.state = respond choose s.iss ( initial seqno ) or set from init cookies initialize s.gar := s.iss set s.isr , 		</variable>
		<variable>s.gsr , 		</variable>
		<action type="receive">s.swl , 		</action>
		<variable>s.swh from packet or init cookies continue with s.state == respond /* 		</variable>
		<action type="issue"><arg> a <ref_event id="2" type="send">response</ref_event> packet </arg> will be generated in step 11 */ 		</action> 
		<trigger>otherwise , 		</trigger> 
		<trigger>generate <ref_event id="8" type="send">reset</ref_event> ( no connection ) unless p.type == <ref_event id="8" type="send">reset</ref_event>  		</trigger>
		<action type="receive">drop packet and return 		</action>
	</control>
</control>

<control relevant="true">
	<trigger>if s.state == <ref_state id="3">request</ref_state> , 	</trigger> 

	<control relevant="true">
		<trigger>if ( p.type == <ref_event id="2" type="receive">response</ref_event> or p.type == <ref_event id="8" type="receive">reset</ref_event> )  		</trigger>and s.awl &lt;= p.ackno &lt;= s.awh ,  /* 
		<trigger>set sequence number variables corresponding to the  		</trigger>
		<trigger>other endpoint , 		</trigger>
		<variable>so p will pass the tests in step 6 */ 		</variable> 
		<trigger>set s.gsr , 		</trigger>
		<variable>s.isr , 		</variable>
		<variable>s.swl , 		</variable>s.swh /* <ref_event id="2" type="None">response</ref_event> processing continues in step 10 ; <ref_event id="8" type="None">reset</ref_event>  
		<action type="receive">processing continues in step 9 */ 		</action> 
		<trigger>otherwise , 		</trigger> /* only <ref_event id="2" type="None">response</ref_event> and <ref_event id="8" type="None">reset</ref_event> are valid in <ref_event id="1" type="None">request</ref_event> state */  
		<error>generate <ref_event id="8" type="send">reset</ref_event> ( packet error )  		</error>
		<action type="receive">drop packet and return 		</action>
	</control>
</control>

<control relevant="true">
	<trigger>if p.type == <ref_event id="9" type="receive">sync</ref_event> or p.type == <ref_event id="10" type="receive">syncack</ref_event> , 	</trigger> 

	<control relevant="true">
		<trigger>if s.awl &lt;= p.ackno &lt;= s.awh and p.seqno &gt;= s.swl , 		</trigger> /* p is valid , so update sequence number variables  accordingly . after this update , 
		<variable>p will pass the tests in step 6 . 		</variable>
		<action type="issue"><arg> a <ref_event id="10" type="send">syncack</ref_event> </arg> is generated 		</action>
		<trigger>if necessary in step 15 */ 		</trigger> 
		<transition>update s.gsr , 		</transition>s.swl , s.swh  
		<trigger>otherwise , 		</trigger> drop packet and return 
	</control>
</control>

<control relevant="true">
	<trigger>if p.x == 0 and the relevant allow short seqnos feature is 0 , 	</trigger> /* packet has short seqnos , but short seqnos not allowed */  
	<action type="receive">drop packet and return  	</action>
	<trigger>otherwise , 	</trigger>
	<trigger>if p.x == 0 , 	</trigger> extend p.seqno and p.ackno to 48 bits using the procedure  in section 7.6  
</control>

<control relevant="true">
	<trigger>if p.type == <ref_event id="6" type="receive">closereq</ref_event> or p.type == <ref_event id="7" type="receive">close</ref_event> or p.type == <ref_event id="8" type="receive">reset</ref_event> , 	</trigger> 
	<variable>lswl := s.gsr + 1 , 	</variable>
	<variable>lawl := s.gar  	</variable>
</control>

<control relevant="true">
	<trigger>if lswl &lt;= p.seqno &lt;= s.swh  	</trigger>
	<trigger>and ( p.ackno does not exist or lawl &lt;= p.ackno &lt;= s.awh ) , 	</trigger> 
	<transition>update s.gsr , 	</transition>
	<variable>s.swl , 	</variable>s.swh  

	<control relevant="true">
		<trigger>if p.type != <ref_event id="9" type="receive">sync</ref_event> , 		</trigger> 
		<transition>update s.gar  	</transition> 
	</control>
	<trigger>otherwise , 	</trigger> 

	<control relevant="true">
		<trigger>if p.type == <ref_event id="8" type="receive">reset</ref_event> , 		</trigger> 
		<action type="send">send <arg> <ref_event id="9" type="send">sync</ref_event> packet acknowledging s.gsr </arg>  		</action>
		<trigger>otherwise , 		</trigger> 
		<action type="send">send <arg> <ref_event id="9" type="send">sync</ref_event> packet acknowledging p.seqno </arg>  	</action> 
	</control>
	<action type="receive">drop packet and return  	</action>
</control>

<control relevant="true">
	<trigger>if ( s.is_server and p.type == <ref_event id="6" type="receive">closereq</ref_event> )  	</trigger>
	<trigger>or ( s.is_server and p.type == <ref_event id="2" type="receive">response</ref_event> ) or ( s.is_client and p.type == <ref_event id="1" type="receive">request</ref_event> ) or ( s.state &gt;= <ref_state id="6">open</ref_state> and p.type == <ref_event id="1" type="receive">request</ref_event>  and p.seqno &gt;= s.osr )  	</trigger>
	<trigger>or ( s.state &gt;= <ref_state id="6">open</ref_state> and p.type == <ref_event id="2" type="receive">response</ref_event>  and p.seqno &gt;= s.osr )  	</trigger>
	<action type="receive">or ( s.state == respond and p.type == <ref_event id="3" type="receive">data</ref_event> ) , 	</action> 
	<action type="send">send <arg> <ref_event id="9" type="send">sync</ref_event> packet acknowledging p.seqno drop packet and return </arg>  	</action>
</control>

<control relevant="true">
	<trigger>if p.type == <ref_event id="8" type="receive">reset</ref_event> , 	</trigger> 
	<action type="receive">tear down connection  	</action>
	<transition>s.state := <ref_state id="9">timewait</ref_state>  	</transition>
	<timer>set timewait timer  	</timer>
	<action type="receive">drop packet and return 	</action>
</control>

<control relevant="true">
	<trigger>if s.state == <ref_state id="3">request</ref_state> , 	</trigger> /* 

	<control relevant="true">
		<trigger>if we get here , 		</trigger>
		<action type="receive">p is a valid <ref_event id="2" type="receive">response</ref_event> from the server ( see  step 4 ) , 		</action>
		<transition>and we should move to <arg_target><ref_state id="5">partopen</ref_state></arg_target> state . 		</transition>
		<action type="send">partopen means send <arg> an <ref_event id="4" type="send">ack</ref_event> </arg> , 		</action>
		<action>do n ` t <ref_event id="3" type="None">data</ref_event> packets , 		</action>
		<action type="receive">retransmit acks periodically , 	</action>
	</control>
	<action type="receive">and always include any init cookie from the <ref_event id="2" type="receive">response</ref_event> */ 	</action> 
	<transition>s.state := <ref_state id="5">partopen</ref_state> set <ref_state id="5">partopen</ref_state> timer continue with s.state == <ref_state id="5">partopen</ref_state> /* 	</transition>
	<action type="send">step 12 will send <arg> the <ref_event id="4" type="send">ack</ref_event> </arg> completing the three-way  	</action>
	<action type="send">handshake */ 	</action>
</control>

<control relevant="true">
	<trigger>if s.state == <ref_state id="4">respond</ref_state> , 	</trigger> 

	<control relevant="true">
		<trigger>if p.type == <ref_event id="1" type="receive">request</ref_event> , 		</trigger> send <ref_event id="2" type="None">response</ref_event> , possibly containing init cookie  

		<control relevant="true">
			<trigger>if init cookie was sent , 			</trigger> destroy s and return /* 
		</control>
		<action type="receive">step 3 will create another socket 		</action>
		<trigger>when the client  		</trigger>
		<action type="send">completes the three-way handshake */ 		</action> 
		<trigger>otherwise , 		</trigger> s.osr := p.seqno  
		<transition>s.state := <ref_state id="6">open</ref_state> 		</transition>
	</control>
</control>

<control relevant="true">
	<trigger>if s.state == <ref_state id="5">partopen</ref_state> , 	</trigger> 

	<control relevant="true">
		<trigger>if p.type == <ref_event id="2" type="receive">response</ref_event> , 		</trigger> send <ref_event id="4" type="None">ack</ref_event>  
		<trigger>otherwise , 		</trigger>
		<trigger>if p.type != <ref_event id="9" type="receive">sync</ref_event> , 		</trigger> s.osr := p.seqno  
		<transition>s.state := <ref_state id="6">open</ref_state> 		</transition>
	</control>
</control>

<control relevant="true">
	<trigger>if p.type == <ref_event id="6" type="receive">closereq</ref_event> and s.state &lt; <ref_state id="7">closereq</ref_state> , 	</trigger> generate <ref_event id="7" type="None">close</ref_event>  
	<transition>s.state := <ref_state id="8">closing</ref_state>  	</transition>
	<timer>set closing timer 	</timer>
</control>

<control relevant="true">
	<trigger>if p.type == <ref_event id="7" type="receive">close</ref_event> , 	</trigger> 
	<action type="issue">generate <arg> <ref_event id="8" type="send">reset</ref_event> ( closed ) </arg> tear down connection drop packet and return 	</action>
</control>

<control relevant="true">
	<trigger>if p.type == <ref_event id="9" type="receive">sync</ref_event> , 	</trigger> 
	<action type="issue">generate <arg> <ref_event id="10" type="send">syncack</ref_event> </arg> 	</action>
</control>

<control relevant="true">
	<trigger>if cscov is 1 , 	</trigger>
	<action type="receive">none of the application <ref_event id="3" type="receive">data</ref_event> is protected by the header checksum . 	</action>
</control>

<control relevant="true">
	<trigger>if mincscov = 0 , 	</trigger>
	<variable>then dccp b only finds packets with cscov = 0 acceptable . 	</variable>
</control>

<control relevant="true">
	<trigger>if mincscov &gt; 0 , 	</trigger>
	<variable>then dccp b additionally finds packets with cscov &gt;= mincscov acceptable . 	</variable>
</control>

<control relevant="true">
	<trigger>if it checks the checksum , 	</trigger>
	<action type="receive">it computes the received <arg> application <ref_event id="3" type="receive">data</ref_event> </arg> ` s crc-32c using the same algorithm as the sender and compares the result with the <ref_event id="3" type="receive">data</ref_event> checksum value . 	</action>
</control>

<control relevant="true">
	<trigger>if the crcs differ , 	</trigger>
	<action type="receive">the endpoint reacts in one of two ways :  	</action> 
	<action type="receive">o the receiving application may have requested delivery of known- corrupt <ref_event id="3" type="receive">data</ref_event> via some optional api . 	</action>in this case , 
	<action type="receive">the packet ` s <ref_event id="3" type="receive">data</ref_event> must be delivered to the application , 	</action>with a note that it is known to be corrupt . furthermore , 
	<action type="receive">the receiving endpoint must report the packet as delivered corrupt using a <ref_event id="3" type="receive">data</ref_event> dropped option ( drop code 7 , delivered corrupt ) . 	</action>  o 
	<trigger>otherwise , 	</trigger>
	<action type="receive">the receiving endpoint must drop the application <ref_event id="3" type="receive">data</ref_event> and report that <ref_event id="3" type="receive">data</ref_event> as dropped due to corruption using a <ref_event id="3" type="receive">data</ref_event> dropped option ( drop code 3 , corrupt ) . 	</action>
</control>

<control relevant="true">
	<trigger>if the crcs differ , 	</trigger>
	<action type="receive">the packets similarly must be reported using <ref_event id="3" type="receive">data</ref_event> dropped options ( drop code 3 ) 	</action>
</control>

<control relevant="true">
	<trigger>new connections start with ccid 2 for both endpoints . 	</trigger>
	<trigger>if this is unacceptable for a dccp endpoint , 	</trigger>
	<action type="send">that endpoint must send <arg> mandatory change ( ccid ) options </arg> on its first packets . 	</action>
</control>

<control relevant="true">
	<trigger>if a <ref_event id="1" type="receive">dccp-request</ref_event> contains the option sequence `` change l ( ccid , 3 ) , 	</trigger>
	<variable>128 `` , 		</variable>

	<control relevant="true">
		<error>the ccid-specific option `` 128 `` may be processed either by ccid 3 ( if the server supports ccid 3 ) or by the default ccid 2 ( if it does not ) . 		</error>
	</control>
</control>

<control relevant="true">
	<trigger>if a <ref_event id="1" type="receive">dccp-request</ref_event> contains the option sequence `` mandatory , 	</trigger>
	<variable>change l ( ccid , 3 ) , 	</variable>
	<error>128 `` , 	</error>
	<action type="receive">then either the `` 128 `` option will be processed by ccid 3 or the connection will be <ref_event id="8" type="receive">reset</ref_event> . 	</action>
</control>

<control relevant="true">
<trigger>therefore , 	</trigger>
	<trigger>dccp senders and receivers should <ref_event id="8" type="receive">reset</ref_event> their congestion state -- essentially restarting congestion control from `` slow start `` or equivalent -- on significant changes in the end-to-end path . 	</trigger>
</control>

<control relevant="true">
<trigger>for example , 	</trigger>
	<action type="send">an endpoint that sends or receives <arg> a mobile ipv6 binding update message </arg> should <ref_event id="8" type="send">reset</ref_event> its congestion state for any corresponding dccp connections . 	</action>
</control>

<control relevant="true">
	<trigger>a dccp implementation may also <ref_event id="8" type="receive">reset</ref_event> its congestion state 	</trigger>
	<trigger>when a ccid changes ( that is , when a negotiation for the ccid feature completes successfully and the new feature value differs from the old value ) . 	</trigger>
</control>

<control relevant="true">
	<trigger>the hc-sender should occasionally inform the hc-receiver that it has received an <ref_event id="4" type="receive">ack</ref_event> . 	</trigger>
	<trigger>if it did not , 	</trigger>
	<trigger>the hc-receiver might resend complete <ref_event id="4" type="receive">ack</ref_event> vector information , 	</trigger>
	<variable>going back to the start of the connection , 	</variable>
	<action type="receive">with every <ref_event id="4" type="receive">dccp-ack</ref_event> packet ! 	</action>
</control>

<control relevant="true">
	<trigger>if dccp b wants to elicit an acknowledgement , 	</trigger>
	<action type="send">it can send <arg> a <ref_event id="9" type="send">dccp-sync</ref_event> . </arg> 	</action>
</control>

<control relevant="true">
	<trigger>if the <ref_event id="3" type="receive">data</ref_event> packets are too big to carry acknowledgement information , 	</trigger>
	<trigger>or 	</trigger>
	<trigger>if the <ref_event id="3" type="send">data</ref_event> sending rate is lower than <ref_event id="4" type="send">ack</ref_event> ratio would suggest , 	</trigger>
	<action type="send">then dccp b should send <arg> enough pure <ref_event id="4" type="send">dccp-ack</ref_event> packets to maintain the rate of one acknowledgement per <ref_event id="4" type="send">ack</ref_event> ratio received <ref_event id="3" type="send">data</ref_event> packets . </arg> 	</action>
</control>

<control relevant="true">
	<trigger>receivers should send acknowledgements immediately on receiving packets marked ecn congestion experienced or packets whose out- of-order sequence numbers potentially indicate loss . 	</trigger>
</control>

<control relevant="true">
	<trigger>the term `` ecn marked `` refers to packets with ecn code point 11 , 	</trigger>
	<trigger>ce ( congestion experienced ) ; 	</trigger>
	<action type="receive"><arg> packets </arg> received with this ecn code point must be reported using state 1 , 	</action>
	<action type="receive">received <arg> ecn marked </arg> . 	</action>
</control>

<control relevant="true">
	<trigger>packets received with ecn code points 00 , 	</trigger>
	<trigger>01 , 	</trigger>
	<trigger>or 10 ( non-ect , ect ( 0 ) , 	</trigger>
	<trigger>or ect ( 1 ) , 	</trigger>respectively ) must be reported using state 0 , received . 
</control>

<control relevant="true">
	<trigger>for an old state of 0 ( received non-marked ) and received state of 1 ( received ecn marked ) , 	</trigger>
	<transition>the packet ` s new state may be set to either 0 or 1 . 	</transition>
</control>

<control relevant="true">
	<trigger>when the stored state is 1 and the received state is 0 , 	</trigger>
	<transition>the receiver is allowed to switch its stored state to 0 . 	</transition>
</control>

<control relevant="true">
	<trigger>if the ecn incapable/a feature is one , 	</trigger>
	<action type="send">then <arg> all of dccp b ` s packets </arg> must be sent as ecn incapable . 	</action>
</control>

<control relevant="true">
	<trigger>if a dccp is not ecn capable , 	</trigger>
	<action type="send">it must send <arg> mandatory `` change l ( ecn  incapable , 1 ) `` options to the other endpoint until acknowledged ( by `` confirm r ( ecn incapable , 1 ) `` ) or the connection closes . </arg> 	</action>furthermore , 
	<action type="receive">it must not accept any <ref_event id="3" type="receive">data</ref_event> until the other endpoint  	</action>  
	<action type="receive">rfc 4340 datagram congestion control protocol ( dccp ) march 2006  	</action>
	<action type="send">sends `` <arg> confirm r ( ecn incapable </arg> , 1 ) . 	</action>
	<error>`` 	</error>
</control>

<control relevant="true">
	<action type="send">it should send <arg> <ref_event id="3" type="send">data</ref_event> dropped options on its acknowledgements </arg> , 	</action>
	<action type="receive">with drop code 0 ( `` protocol constraints `` ) , 	</action>
	<action type="send">if the other endpoint does send <arg> <ref_event id="3" type="send">data</ref_event> </arg> inappropriately . 	</action>
</control>

<control relevant="true">
	<trigger>upon detecting possible misbehavior , 	</trigger>
	<action type="receive">a sender should respond as 	</action>
	<trigger>if the receiver had reported one or more recent packets as ecn-marked ( instead of unmarked ) , 	</trigger>
	<action type="receive">while a receiver should report one or more recent non-marked packets as ecn-marked . 	</action>
</control>

<control relevant="true">
	<action type="receive">a dccp receiving <arg> a timestamp option </arg> should respond with a timestamp echo option on the next packet it sends . 	</action>
</control>

<control relevant="true">
	<trigger>if elapsed time is less than a half-second , 	</trigger>
	<trigger>the first , 	</trigger>
	<action type="receive">smaller form of the option should be used . 	</action>
</control>

<control relevant="true">
	<trigger>if an endpoint has received multiple timestamp options since the last time it sent a packet , 	</trigger>
	<action type="receive">then it may ignore all timestamp options but the one included on the packet with the greatest sequence number . 	</action>alternatively , 
	<action type="receive">it may include multiple timestamp echo options in its <ref_event id="2" type="receive">response</ref_event> , 	</action>each corresponding to a different timestamp option . 
</control>

<control relevant="true">
	<trigger>if the application provides <ref_event id="3" type="receive">data</ref_event> that , 	</trigger>when combined with the options the dccp implementation would like to include , 
	<variable>would exceed the mps , 	</variable>
	<action type="send">the implementation should either send <arg> the options </arg> on a separate packet ( such as a <ref_event id="4" type="send">dccp-ack</ref_event> ) or lower the mps , 	</action>
	<action type="receive">drop the <ref_event id="3" type="receive">data</ref_event> , 	</action>
	<action type="receive">and return an appropriate error to the application . 	</action>
</control>

<control relevant="true">
	<trigger>when a router receives a packet with df set that is larger than the next link ` s mtu , 	</trigger>
	<action type="send">it sends <arg> an icmp destination unreachable message </arg> back to the source whose code indicates that an unfragmentable packet was too large to forward ( a `` datagram too big `` message ) . 	</action>
</control>

<control relevant="true">
	<trigger>when a dccp implementation receives a datagram too big message , 	</trigger>
	<action type="receive">it decreases its pmtu to the next-hop mtu value given in the icmp message . 	</action>
</control>

<control relevant="true">
	<trigger>if the mtu given in the message is zero , 	</trigger>
	<variable>the sender chooses a value for pmtu using the algorithm described in , 	</variable>section 7 . 
</control>

<control relevant="true">
	<trigger>if the mtu given in the message is greater than the current pmtu , 	</trigger>
	<action type="receive">the datagram too big message is ignored , 	</action>as described in . 
</control>

<control relevant="true">
	<trigger>a dccp sender may treat the reception of an icmp datagram too big message as an indication that the packet being reported was not lost due to congestion , 	</trigger>
	<action type="receive">and so for the purposes of congestion control it may ignore the dccp receiver ` s indication that this packet did not arrive . 	</action>
</control>

<control relevant="true">
	<trigger>if this is done , 		</trigger>

	<control relevant="true">
		<action type="receive">then the dccp sender must check the ecn bits of the ip header echoed in the icmp message and only perform this optimization 		</action>
		<trigger>if these ecn bits indicate that the packet did not experience congestion prior to reaching the router whose link mtu it exceeded . 		</trigger>
	</control>
</control>

<control relevant="true">
	<trigger>if more than three odd datagram too big messages are received and the other dccp endpoint reports more than three lost packets , 	</trigger>however , 
	<action type="receive">the dccp implementation should assume the presence of a confused router and either obey the icmp messages ` pmtu or ( on ipv4 networks ) switch to allowing fragmentation . 	</action>
</control>

<control relevant="true">
	<trigger>on ipv4 connections whose applications have requested fragmentation , 	</trigger>
	<variable>the sender should send packets with the df bit not set . 	</variable>
</control>

<control relevant="true">
	<trigger>on ipv6 connections whose applications have requested fragmentation , 	</trigger>
	<action type="receive">the sender should use fragmentation extension headers to fragment packets larger than pmtu into suitably-sized chunks . 	</action>
</control>

<control relevant="true">
	<trigger>if the dccp implementation has decreased the pmtu , 	</trigger>
	<action type="send">the sending application has not requested fragmentation , 	</action>
	<action type="send">and the sending application attempts to send a packet larger than the new mps , 	</action>
	<action type="send">the api must refuse to send <arg> the packet </arg> and return an appropriate error to the application . 	</action>the application should 
	<action type="receive">then use the api to query the new value of mps . 	</action>the kernel might have some packets buffered for transmission that are smaller than the old mps but larger than the new mps . 
	<action type="send">it may send <arg> these packets </arg> as fragmentable , 	</action>
	<action type="receive">or it may discard these packets ; 	</action>it must not send them as unfragmentable . 
</control>

<control relevant="true">
	<trigger>for example , 	</trigger>
	<action type="receive">dccp processors must not <ref_event id="8" type="receive">reset</ref_event> the connection 	</action>
	<trigger>if some field marked reserved in this specification is non-zero ; 	</trigger>
	<trigger>if some unknown option is present ; 	</trigger>
	<trigger>or 	</trigger>
	<trigger>if some feature negotiation option mentions an unknown feature . 	</trigger>
	<trigger>instead , 	</trigger>dccp processors must ignore these events . 
</control>

<control relevant="true">
	<trigger>if mandatory precedes some unknown option or feature , 	</trigger>
	<action type="receive">the connection must be <ref_event id="8" type="receive">reset</ref_event> . 	</action>
</control>

<control relevant="true">
	<action type="receive">a dccp must respond with an empty confirm option 	</action>
	<trigger>if it is assigned an unacceptable value for some non-negotiable feature . 	</trigger>
</control>

<control relevant="true">
	<trigger>if an extended dccp wants to use the extension , 	</trigger>
	<action type="receive">it should attempt to change the feature ` s value using a change l or change r option . 	</action>
	<trigger>any non-extended dccp will ignore the option , 	</trigger>
	<action type="receive">thus leaving the feature value at its default , 	</action>
	<error>`` extension not available `` . 	</error>
</control>
</p>